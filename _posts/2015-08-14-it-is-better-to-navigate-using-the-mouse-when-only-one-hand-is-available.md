---
layout: post
published: false
title: Lightweight
stacking window manager developers: stop making it hard to use a computer with one hand
tags: null
---


Do you always sit like [this](http://pad2.whstatic.com/images/thumb/a/ac/Sit-at-a-Computer-Step-7-Version-2.jpg/670px-Sit-at-a-Computer-Step-7-Version-2.jpg) when using a computer? No, I don't either. 

There is a saying that a good programmer can type with his eyes closed. This is arguably true, but it relies on the assumption that a good programmer will always have two hands on the keyboard, and keep their fingers on the home row. This is often touted as desirable due to having a familiar point of reference, such as the notch usually built into most keyboard's 'j' key. Using tacticle response in this way allows the user to stay spatially aware, and use muscle memory to figure out where all the other keys are, without even needing to glance down. But I'm going to argue that although this may be the desirable way to operate a machine in theory, it isn't always in practice. We need to stop making assumptions about ergonomics based on arcane UNIX documents from the 70s, when computers were limited to the computer lab, and get with the times.

Assuming that the majority of more casual computer users will always sit with perfect posture, with eye-level always at the same position in relation to their monitor, and always in the same position in relation to their keyboard, is silly and infeasible in this day-and-age. People are on the move with laptops and netbooks. And even people using stationary workstations still won't always sit with perfect posture, with both hands on the keyboard. Perhaps sometimes they will eat a bag of Monster Munch while browsing the internet, or sip some mountain dew another time. In theory, perhaps we should always sit in with correct posture and a familiar position for health reasons, but in practice most people don't, and you shouldn't expect them to.

I wouldn't even be arsed to make a whole post about this, but in my quest to find a portable and unbloated stacking window manager, it pissed me off to see so many *nix users patronising other users who still like at least some basic mouse usage in their window managers. Look, being forced to hold onto MOD key + trackpoint button click on my laptop just to raise a window when I'm using one hand, sitting away from the keyboard, relegates your window manager to the usability levels of the Xerox Park. Fair enough, you gave up your time to make it for free, and no one forced me to waste 10 minutes of my life installing and quickly deleting it, but please stop trying to push your arcane, and academically dishonest ideas about computer minimalism to the masses. 

I'm not going to go into the reasons why tiling window managers don't suit my workflow, as it will only take away from the focus of this post, which is about stacking window managers. Instead, I'm going to argue that there is a specific use case where a pointing device objectively excels over the keyboard in stacking window management: one-handed use when positioned away from the keyboard, eyes firmly centered on the screen, and not doing a lot of typing. One additional assumption to keep in mind is that the user is often operating in different work environments, e.g., shifted into awkward positions, such as sitting on their living room couch. I want to outline why such operation is the norm rather than the exception for many peoples computer workflows. Some examples of when it is comfortabler to operate further back from the keyboard, with only one-hand are when:

-  reading ebooks, doing web research, and watching media for long periods of time (e.g., shifting body weight to get comfortable)
-  flicking through and referencing physical documents
-  cuddling the girfriend
-  lying on the couch with a laptop on lap
-  having a cup of coffee
-  eating
-  scratching the neckbeard

I.e., most of the time, and especially in this day-and-age when most people own laptops, and are often not at a desk. It's a lot comfortabler to just lean back when e.g., browsing web pages for hours on end. And it is a lot easier to just keep one hand on the nub stick, mouse, or movement keys because they are easy targets to feel out and hit without needing to eye strain. People who code for their day job may well spend more time lurched over the keyboard, with eyes semi-fixated on the keys, and both hands on the keyboard. However, someone who only casually codes, such as myself, will spend only an hour or two typing intensely in this manner, whereas they will spend more time with eyes mainly focused on the screen, possibly slouching, hand only partially rested on the input device, browsing the web, researching, and copy and pasting the odd bit of text (in my case with a laptop trackpoint).

Sadly, there is a trend of stacking window manager devs to make it very hard for their users to operate their machines with one hand in this way. They self-righteously go on-and-on about how their window manager is  "simple, usable, and lightweight" because it relies only on the keyboard, as if using a trackpoint or other pointing device is inherantly inferior for all use cases. Such devs deliberately ommit any code that would offer some flexibility for those who prefer mouse usage. In particular, they love to leave out a click-to-raise policy (clicking anywhere in the visible part of a window to raise it above others), even though it would only take someone with their level of coding expertise minimal effort to add a couple lines of xlib/xcb calls to support this feature, if only as a nice gesture to their more casual users. But no, they would rather force impose their own window management philosophies on you. Sure, they are entitled to do so, but I'm entitled to be pissed off when they start proudly spreading their shit philosophies, which operate under the misguided assumption that everyone is a programmer, who is always positioned over the keyboard with two hands on the home row. 

Alternative policies such as sloppy focus or click-to-focus are probably great for someone who spends all day writing code in the aforementioned manner, but the modern day, casual user (one who often operates with only one hand on an input device) really finds click-to-raise essential. Otherwise, their web browsing experience is completely fucked, as they now have to pinky stretch to a modifier key just to e.g., switch to an editor when pasting research notes.

In other cases, you get some devs who think because they offer clickable titlebars and borders, they absolutley must not allow click-to-raise policy too. But titlebars and borders offer small and awkward to hit targets, whereas click-to-raise lets the user aim for the much larger target of the whole window. Remember here: I'm only talking in the context of one-handed usage, where it is just as awkward to frequently snap up to the window edges and click titlebars and borders as it is to force-stretch the pinky finger to a mod key to click and raise. 

I've tried to play devils advocate with myself and not use the trackpoint (or touchpad) on my laptop for a week, and disable click-to-raise, but operating mod-key bound window manager shortcuts with one hand is just plain awkward, however elaborate the keybinding setup. It isn't too bad when I'm sat up right and mostly doing typing work anyway, but the moment my arse starts to hurt and I want to move somewhere comfy like the couch, it is game over. Even to do something as basic as find the 'j' key to scroll a webpage using VimFX extensions, I have to move my finger round in a circle to feel for the notch on the 'J' key, because I don't have enough spacial awareness of where my hand is in relation to the keys, and I have to strain my eyes to see it.

Yes, it may surprise you to know that I do still advocate heavier than usual keyboard usage e.g., installing vim like browser extensions to scroll up and down. I just don't take such a hard line and dogmatic view on trying to get rid of the mouse completely. I use keyboard combinations in conjunction with trackpoint usage to great effect. When I'm in a more comprimised position I use the trackpoint, and when I'm mainly in the mode of typing I lean more heavily towards keyboard shortcuts.

Top-level WM shortcuts inherantly require a modifier key (e.g., holding onto 'Alt' key or 'Windows' key, and will do so until the day when someone designs advanced AI that can contextually detect when someone is typing, rather than performing a management action on the window frame itself. The problem with needing to hold or keychain a modifier key, however, is that, as aforementioned, when you are in an environemt where you shift about a lot (such as balancing a laptop on lap on the couch) there are plenty of times when only one hand is rested on the keyboard, but without a full awareness of the key positions. This means wasted time eye scanning for the positions of keys. Even if you know the position of one key e.g., you can feel the bevelled 'J' key on a Thinkpad, it is still too easy to overcompensate and move too far away from the key. The fact is, if you are not positioned over the keyboard, it is too hard to maintain spacial awareness, and the familiar context needed to consistently find keys without looking down away from the screen. Having to scan for keys is compounded by having to think about the quickest order to press elaborate key combinations and/or chains, and leads to a broken train-of-thought, which can disrupt even the simplest of tasks. Pointing devices offer a much fluider, autonomous, and less disruptive response in such situations. 

As an example, take the common task of copying some text from your web browser to a terminal using just the keyboard. Even assuming you have a keyboard-optimised browsing extension enabled, you still need to either move the caret to select text, or search for the start point of the text, create a mark, and search for the end point. This will also require switching modes if using vim-like keybindings, or using finger gymnastics if using emacs-like keybindings (remember, we operate on the assumption that you won't always have both hands available when casually using a computer). Either way, this generates a lot of mental activity that frustrates ones train of thought, because you have to specifically pick out which characters will set the boundaries of your selection, then act. Whereas just selecting the text with a mouse is an almost subconscious action, and one that only requires to pin-point a couple of spatial targets. Once you get in and around the area you want to select, it is easy to change your mind, as the mouse is already in the right area -- it will require just a small offset -- whereas changing your mind with keyboard selection will require a potentially full travel across the keyboard for each adjustment to the selection you make. 

If we try to think of a way to replace the pointing device with the keyboard for this typical one handed, casual usage, then a key map is needed that prevents too much travel across the keyboard, and one that prevents finger gymnastics to press the right keyboard combinations. But how is such a keymap achieved? Hypothetically, I could bind all my window manager binds to the right side of the keyboard; that way, when I'm trying to use my computer with one hand, I don't need to keep reaching across the keyboard to hit the Enter key. However, I'm yet to find a keyboard without the ergonomical problems that make it uncomfortable to perform key-combos. Here are the ergonomical problems:

 - the placement of right Ctrl on most keyboards is hard to discover and usually requires a pinky stretch (especially on laptops where it is squashed in by the arrow keys)
 - right Shift is practically unreachable as a modifier, and better served as a replacement for CapsLock when typing single-handedly
 - right Alt key is accessible with the thumb, but the muscle movement to position on it still often misaligns your other fingers off the home row, and most applications use it on the top-level anyway, so Alt is inflexible as a modifier for window management keys

And yes, I've considered using Ratpoision like prefix maps to prevent key clobbering when using right Alt key e.g., pressing right Alt, letting go to load a list of key shortcuts, then pressing e.g., bracket keys to switch windows. This solves the finger gymnastics problem, and is easily implemented with xbindkeys, but it still requires looking down at the keyboard and scanning for the keys, whereas using a pointing device is subconscious, and requires little thought or effort. 

And even if there is a keyboard out there that works well with right handed key bindings (thus allowing shorter travel to the Enter key), it still doesn't guarantee access to such a keyboard across computers. Admittedly, on the left side of the keyboard, the problems listed above don't exist, as remapping CapsLock as a Ctrl key or using the Win key as a modifier is possible -- both of which are easily discoverable. Even so, one handed usage still requires travelling right across the keyboard to press Enter. I've considered rebinding Enter to e.g., Ctrl, but this, again, isn't a very portable solution, and is probably asking for disaster in a terminal. Whereas, when operating e.g., a trackpoint, I'm always close to the Enter key, and don't need to use keyboard modifiers such as Ctrl for basic and frequent operations, such as copy, paste, drag and moving of windows and objects. This ability to drag, move, and resize is also why titlebar and thick borders are still a good idea for trackpoint use, even though they do waste a small (negligible) amount of screen space. 

The tl;dr of this post is that all stacking window managers should at least optionally support:

 - click-to-raise
 - rudimentary draggable titlebars with close buttons
 - resizable borders

And the simple reason for this is that we can't always guarantee it is comfortable or desirable to have two hands placed on a keyboard. 

I'd make similar arguments for tiling window managers, as most of them don't do enough to at least offer some basic mouse support for a few edge cases where a tiling work flow could benefit from mouse actions. Sadly, that would take a whole other post entirely to justify my arguments, so I'm not going to bother getting into it.
